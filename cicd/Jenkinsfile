def REPOS = [
  'user-service': 'https://github.com/DRSOL-HA/WebBoard-Service.git',
  'file-service': 'https://github.com/DRSOL-HA/WebBoard-Service.git',
  'post-service': 'https://github.com/DRSOL-HA/WebBoard-Service.git',
  'frontend'    : 'https://github.com/DRSOL-HA/WebBoard-Service.git',
  'nginx'       : 'https://github.com/DRSOL-HA/WebBoard-Service.git',
]

pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: buildkit
spec:
  serviceAccountName: jenkins
  containers:
  - name: buildctl
    image: moby/buildkit:rootless
    command: ["cat"]
    tty: true
    volumeMounts:
    - { name: tls, mountPath: /tls, readOnly: true }
    - { name: workspace-volume, mountPath: /home/jenkins/agent }

  - name: git
    image: alpine/git:2.45.2
    command: ["cat"]
    tty: true
    # git이 만드는 파일 소유자 일관성 위해 root
    securityContext: { runAsUser: 0, runAsGroup: 0 }
    volumeMounts:
    - { name: workspace-volume, mountPath: /home/jenkins/agent }

  - name: yq
    image: ghcr.io/mikefarah/yq:4
    command: ["cat"]
    tty: true
    # yq도 root로 실행해 파일 쓰기 보장
    securityContext: { runAsUser: 0, runAsGroup: 0 }
    volumeMounts:
    - { name: workspace-volume, mountPath: /home/jenkins/agent }

  - name: curl
    image: alpine:3.20
    command: ["cat"]
    tty: true
    securityContext: { runAsUser: 0, runAsGroup: 0 }
    volumeMounts:
    - { name: workspace-volume, mountPath: /home/jenkins/agent }

  volumes:
  - name: tls
    secret:
      secretName: buildkit-client-tls
  - name: workspace-volume
    emptyDir: {}
"""
    }
  }

  options {
    disableConcurrentBuilds()
    skipDefaultCheckout(true)
  }

  parameters {
    choice(name: 'SERVICE',
           choices: 'user-service\nfile-service\npost-service\nfrontend',
           description: '빌드/배포할 서비스')
    string(name: 'BRANCH', defaultValue: 'main', description: '빌드 브랜치')
    string(name: 'IMAGE_TAG', defaultValue: '', description: '비우면 서비스별 자동 증가(vN)')
  }

  environment {
    REPO_HTTPS    = 'https://github.com/DRSOL-HA/WebBoard-Service.git'
    REGISTRY      = 'ghcr.io/drsol-ha'
    BUILDKIT_ADDR = 'tcp://buildkitd.buildkit.svc.cluster.local:1234'
  }

  stages {

    stage('Checkout service code') {
      steps {
        container('git') {
          withEnv(["BRANCH=${params.BRANCH}"]) {
            withCredentials([usernamePassword(
              credentialsId: 'GITHUB_PAT',
              usernameVariable: 'GH_USER',
              passwordVariable: 'GH_PAT'
            )]) {
              sh '''
                set -euxo pipefail
                rm -rf src && mkdir -p src
                AUTH=$(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')
                git -c "http.extraheader=AUTHORIZATION: Basic ${AUTH}" \
                  clone --depth=1 -b "$BRANCH" "$REPO_HTTPS" src/app
              '''
            }
          }
        }
      }
    }

    stage('Resolve build context') {
      steps {
        container('git') {
          withEnv(["SERVICE=${params.SERVICE}"]) {
            sh '''
              set -euxo pipefail
              HINT="$(printf '%s' "$SERVICE" | sed 's/-service$//')"
              FOUND=""
              for c in \
                "services/${SERVICE}" "services/${HINT}" \
                "apps/${SERVICE}"     "apps/${HINT}" \
                "packages/${SERVICE}" "packages/${HINT}" \
                "${SERVICE}"          "${HINT}" \
                "apps/${SERVICE}/app" "apps/${HINT}/app" \
                "services/${SERVICE}/app" "services/${HINT}/app"
              do
                if [ -d "src/app/$c" ] && ls "src/app/$c"/Dockerfile* >/dev/null 2>&1; then
                  FOUND="$c"; break
                fi
              done
              [ -n "$FOUND" ] || { echo "ERROR: Dockerfile 경로 탐색 실패"; exit 2; }
              echo "$FOUND" > .build_context_path
              echo "Detected build context: $FOUND"
            '''
          }
        }
      }
    }

    stage('Decide IMAGE_TAG (auto bump when empty)') {
      when { expression { return !(params.IMAGE_TAG?.trim()) } }
      steps {
        container('curl') {
          withCredentials([usernamePassword(credentialsId: 'ghcr',
            usernameVariable: 'GHCR_USER', passwordVariable: 'GHCR_PAT')]) {
            withEnv(["SERVICE=${params.SERVICE}"]) {
              sh '''
                set -euxo pipefail
                # 토큰 교환 및 태그 조회를 위한 도구
                apk add --no-cache curl ca-certificates jq
    
                OWNER="drsol-ha"
                REPO="board-${SERVICE}"
    
                # 1) GHCR 액세스 토큰 발급 (PAT -> registry token)
                #    SSO가 필요한 조직이면 이 호출에서 403/401 나기도 함 → SSO 승인 확인 필요
                TOKEN=$(curl -sS -u "${GHCR_USER}:${GHCR_PAT}" \
                  "https://ghcr.io/token?service=ghcr.io&scope=repository:${OWNER}/${REPO}:pull" \
                  | jq -r .token)
    
                if [ -z "${TOKEN:-}" ] || [ "${TOKEN}" = "null" ]; then
                  echo "ERROR: failed to get GHCR registry token (PAT 권한/SSO 확인 필요)" >&2
                  exit 91
                fi
    
                # 2) 발급받은 Bearer 토큰으로 tags 조회
                CODE=$(curl -sS -o tags.json -w "%{http_code}" \
                  -H "Authorization: Bearer ${TOKEN}" \
                  "https://ghcr.io/v2/${OWNER}/${REPO}/tags/list?n=1000" || true)
    
                if [ "$CODE" = "403" ]; then
                  echo "ERROR: GHCR 403 (token에 pull 권한 없음 → PAT의 read:packages/SSO 확인)" >&2
                  exit 90
                fi
    
                # 2xx가 아니면 신규 레포로 보고 빈 목록으로 간주
                if [ "${CODE:-0}" -lt 200 ] || [ "${CODE:-999}" -ge 300 ]; then
                  echo '{"tags":[]}' > tags.json
                fi
              '''
            }
          }
        }
        container('yq') {
          sh '''
            set -euo pipefail
            NEXT_TAG=$(yq -r '
              .tags // [] 
              | map(select(test("^v[0-9]+$"))) 
              | (map(sub("^v";"") | tonumber) | max // 0) + 1
              | "v" + tostring
            ' tags.json)
            echo "$NEXT_TAG" > .image_tag
            echo "Auto-decided IMAGE_TAG: $NEXT_TAG"
          '''
        }
        script {
          env.IMAGE_TAG = readFile('.image_tag').trim()
          echo "Using IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Use provided IMAGE_TAG (if any)') {
      when { expression { return (params.IMAGE_TAG?.trim()) } }
      steps {
        script {
          env.IMAGE_TAG = params.IMAGE_TAG.trim()
          echo "Using provided IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Build & Push image') {
      steps {
        container('buildctl') {
          withCredentials([usernamePassword(credentialsId: 'ghcr',
            usernameVariable: 'GHCR_USER', passwordVariable: 'GHCR_PAT')]) {
            withEnv(["SERVICE=${params.SERVICE}"]) {
              sh '''
                set -euxo pipefail
    
                CONTEXT_PATH="$(cat .build_context_path)"
                IMAGE_NAME="${REGISTRY}/board-${SERVICE}"
                META="$WORKSPACE/.buildmeta.json"
    
                export HOME="$WORKSPACE"
                export DOCKER_CONFIG="$HOME/.docker"
                mkdir -p "$DOCKER_CONFIG"
    
                AUTH="$(printf '%s:%s' "$GHCR_USER" "$GHCR_PAT" | base64 | tr -d '\n')"
                cat > "$DOCKER_CONFIG/config.json" <<EOF
                { "auths": { "ghcr.io": { "auth": "$AUTH" } } }
                EOF
    
                echo "[buildctl] building ${IMAGE_NAME}:${IMAGE_TAG} from ${CONTEXT_PATH}"
                buildctl --addr "$BUILDKIT_ADDR" \
                  --tlscacert /tls/ca.crt --tlscert /tls/client.crt --tlskey /tls/client.key \
                  build \
                  --frontend=dockerfile.v0 \
                  --local context="src/app/${CONTEXT_PATH}" \
                  --local dockerfile="src/app/${CONTEXT_PATH}" \
                  --output type=image,name="${IMAGE_NAME}:${IMAGE_TAG}",push=true \
                  --metadata-file "$META"
    
                # 푸시 성공 마커
                touch .push_ok
              '''
            }
          }
        }
      }
    }

    stage('Bump manifest tag') {
      steps {
        container('git') {
          withCredentials([usernamePassword(
            credentialsId: 'GITHUB_PAT',
            usernameVariable: 'GH_USER',
            passwordVariable: 'GH_PAT'
          )]) {
            sh '''
              set -euo pipefail
              rm -rf manifest && mkdir -p manifest
              cd manifest
              AUTH=$(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')
              git -c "http.extraheader=AUTHORIZATION: Basic ${AUTH}" \
                clone --depth=1 https://github.com/DRSOL-HA/deploy_manifest.git repo
              cd repo
              git config user.name  "jenkins"
              git config user.email "ci@drsol-ha.local"
            '''
          }
        }

        container('yq') {
          withEnv(["SERVICE=${params.SERVICE}"]) {
            sh '''
              set -euo pipefail
              cd manifest/repo
              FILE="apps/board/kustomization.yaml"
              [ -f "$FILE" ] || { echo "kustomization not found: $FILE"; exit 3; }

              export IMG_LOWER="ghcr.io/drsol-ha/board-${SERVICE}"
              export IMG_UPPER="ghcr.io/DRSOL-HA/board-${SERVICE}"
              export NEW_TAG="${IMAGE_TAG}"

              yq -i '
                (.images[] | select((.name == strenv(IMG_LOWER)) or (.name == strenv(IMG_UPPER))).newTag)
                = strenv(NEW_TAG)
              ' "$FILE"
            '''
          }
        }

        container('git') {
          withCredentials([usernamePassword(
            credentialsId: 'GITHUB_PAT',
            usernameVariable: 'GH_USER',
            passwordVariable: 'GH_PAT'
          )]) {
            sh '''
              set -euo pipefail
              cd manifest/repo
              if git diff --quiet -- .; then
                echo "No manifest changes to commit."
              else
                git add -A
                git commit -m "ci: bump board-${SERVICE} -> ${IMAGE_TAG}"
                AUTH=$(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')
                git -c "http.extraheader=AUTHORIZATION: Basic ${AUTH}" push origin HEAD:main
              fi
            '''
          }
        }
      }
    }
  }
}
